import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

![Anchor Escrow Challenge](/graphics/challenge-banners/anchor-escrow.png)

# Konsep Escrow

Escrow adalah alat finansial yang kuat untuk memfasilitasi pertukaran token yang aman di antara dua pihak.

Escrow dapat dianggap seperti kotak penyimpanan digital di mana satu pengguna dapat mengunci Token A sembari menunggu pengguna lain menyetor Token B sebelum proses pertukaran selesai.

Konsep ini dapat menciptakan lingkungan tanpa kepercayaan di mana kedua belah pihak tidak perlu khawatir tentang pihak lain yang membatalkan kesepakatan secara sepihak.

Dalam tantangan ini, kita akan mengimplementasikan konsep ini melalui tiga instruksi sederhana namun kuat:

- **Make**: Pembuat Escrow (pengguna pertama) menentukan persyaratan pertukaran dan menyetor jumlah Token A yang disepakati ke dalam _vault_ (brankas) yang aman. Ini seperti menempatkan barang Anda di dalam suatu kotak penyimpanan dan menetapkan persyaratan pertukaran.
- **Take**: Pengambil Escrow (pengguna kedua) menerima tawaran dengan mentransfer jumlah Token B sesuai permintaan dalam Escrow kepada pembuat, dan sebagai gantinya, Pengambil Escrow akan secara otomatis menerima Token A yang terkunci dalam _vault_. Ini adalah saat ketika kedua belah pihak menyelesaikan bagian mereka dalam kesepakatan.
- **Refund**: Jika pembuat berubah pikiran atau tidak ada pengambil escrow yang cocok, mereka dapat membatalkan tawaran dan mengambil kembali Token A mereka dari _vault_. Ini seperti mendapatkan kembali barang Anda dari kotak penyimpanan jika kesepakatan gagal.

**Catatan**: Jika Anda tidak familiar dengan Anchor, kami menyarankan anda untuk membaca kursus [Anchor for Dummies](/id/courses/anchor-for-dummies) terlebih dahulu untuk mendalami konsep inti yang akan kita gunakan dalam program ini.

<ArticleSection name="Instalasi" id="installation" level="h2" />

Mari mulai dengan membuat _workspace_ Anchor baru:

```bash
anchor init blueshift_anchor_escrow
cd blueshift_anchor_escrow
```

Kemudian kita lanjutkan dengan mengaktifkan `init-if-needed` pada _crate_ `anchor-lang` dan dengan menambahkan _crate_ `anchor-spl` juga:

```bash
cargo add anchor-lang --features init-if-needed
cargo add anchor-spl
```

Karena kita menggunakan `anchor-spl`, kita juga perlu mengubah file `programs/blueshift_anchor_escrow/Cargo.toml` untuk menyertakan `anchor-spl/idl-build` dalam fitur `idl-build`.

Buka `Cargo.toml` dan Anda akan melihat baris `idl-build` yang sudah ada seperti ini:

```toml
idl-build = ["anchor-lang/idl-build"]
```

Tambahkan `anchor-spl/idl-build` seperti berikut:

```toml
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]
```

Sekarang Anda dapat membuka folder yang baru dibuat, dan Anda siap untuk mulai koding!

<ArticleSection name="Kerangka Awal" id="template" level="h2" />

Kali ini, karena programnya cukup kompleks, kita akan membaginya menjadi modul-modul kecil yang terfokus alih-alih membuat semuanya semuanya dalam file `lib.rs`.

Struktur folder akan terlihat kurang lebih seperti ini:

```
src
├── instructions
│       ├── make.rs
│       ├── mod.rs
│       ├── refund.rs
│       └── take.rs
├── errors.rs
├── lib.rs
└── state.rs
```

Dengan file `lib.rs` yang akan terlihat kurang lebih seperti ini:

```rust
use anchor_lang::prelude::*;

mod state;
mod errors;
mod instructions;
use instructions::*;

declare_id!("22222222222222222222222222222222222222222222");

#[program]
pub mod blueshift_anchor_escrow {
    use super::*;

    #[instruction(discriminator = 0)]
    pub fn make(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
        //...
    }

    #[instruction(discriminator = 1)]
    pub fn take(ctx: Context<Take>) -> Result<()> {
        //...
    }

    #[instruction(discriminator = 2)]
    pub fn refund(ctx: Context<Refund>) -> Result<()> {
        //...
    }
}
```

Seperti yang Anda lihat, kita telah mengimplementasikan diskriminator kustom untuk instruksi-instruksi kita. Jadi pastikan versi anchor Anda adalah 0.31.0 atau yang lebih terkini.

<ArticleSection name="State" id="state" level="h2" />

State adalah struktur data yang akan kita gunakan untuk menyimpan data untuk `Escrow` kita.

Kita akan beralih ke `state.rs` di mana semua data untuk `Escrow` kita berada. Untuk melakukannya, kita akan memberikannya diskriminator kustom dan membungkus `struct` ke dalam makro `#[account]` seperti ini:

```rust
use anchor_lang::prelude::*;

#[derive(InitSpace)]
#[account(discriminator = 1)]
pub struct Escrow {
    pub seed: u64,
    pub maker: Pubkey,
    pub mint_a: Pubkey,
    pub mint_b: Pubkey,
    pub receive: u64,
    pub bump: u8,
}
```

Fungsi masing-masing bagian:

- **seed**: Angka acak yang digunakan selama derivasi _seed_ sehingga satu _maker_ dapat membuka beberapa escrow dengan pasangan token yang sama; disimpan di dalam blockchain (_on-chain_) agar kita selalu dapat mendapatkan kembali nilai PDA yang sesuai.
- **maker**: _Wallet_ yang membuat escrow; diperlukan untuk pengembalian dana dan menerima pembayaran.
- **mint_a** & **mint_b**: Alamat SPL Mint untuk sisi "give" dan "get" dari pertukaran.
- **receive**: Berapa banyak token B yang diinginkan _maker_. (Saldo vault itu sendiri menunjukkan berapa banyak token A yang disetor, jadi kita tidak perlu menyimpan nilai tersebut secara terpisah.)
- **bump**: _Byte bum_p_ yang di-_cache_; menurunkannya secara langsung akan memakan "biaya" komputasi, jadi kita hanya perlu menyimpannya sekali.

Kita sebenarnya dapat juga memasukkan lebih banyak informasi kedalam `struct` kita, akan tetapi, _byte_ yang lebih banyak akan memakan biaya _rent_ yang lebih banyak juga. Oleh karena itu,kita hanya perlu menyimpan data-data kunci untuk menjaga biaya deposit tetap murah dan dalam waktu yang sama tetap memungkinkan program menerapkan setiap instruksi yang dibutuhkan.

Kita selesaikan dengan menambahkan makro `#[derive(InitSpace)]` sehingga kita tidak perlu menghitung biaya sewa struktur ini secara manual.

<ArticleSection name="Definisi Error" id="errors" level="h2" />

Kita sekarang dapat beralih ke file `errors.rs` di mana kita akan menambahkan beberapa definisi error yang akan kita gunakan nanti seperti ini:

```rust
use anchor_lang::prelude::*;

#[error_code]
pub enum EscrowError {
    #[msg("Invalid amount")]
    InvalidAmount,
    #[msg("Invalid maker")]
    InvalidMaker,
    #[msg("Invalid mint a")]
    InvalidMintA,
    #[msg("Invalid mint b")]
    InvalidMintB,
}
```

Setiap enum mengacu ke pesan yang jelas dan mudah dibaca yang akan ditampilkan Anchor setiap kali _constraint_ atau `require!()` gagal.
