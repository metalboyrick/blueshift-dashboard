import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

![Anchor _vault_ Challenge](/graphics/challenge-banners/anchor-vault.png)

# Konsep _Vault_ ( Brankas )

_Vault_ ( Brankas dalam Bahasa Inggris ) adalah suatu program yang memungkinkan pengguna untuk menyimpan aset mereka dengan aman. _vault_ adalah konsep dasar dalam DeFi yang pada intinya memungkinkan pengguna untuk menyimpan aset mereka (_lamport_ dalam kasus ini) dengan aman yang hanya dapat ditarik kembali oleh pengguna yang sama di kemudian hari.

Dalam tantangan ini, kita akan membangun _vault_ _lamport_ sederhana yang menunjukkan cara bekerja dengan akun dasar, _Program Derived Addresses_ (PDA), dan _Cross-Program Invocation_ (CPI). Jika Anda belum familiar dengan Anchor, kami menyarankan anda untuk membaca kursus [Pengantar Anchor](/id/courses/introduction-to-anchor) untuk mendalami konsep inti yang akan kita gunakan dalam program ini.

<ArticleSection name="Proses Instalasi" id="installation" level="h2" />

Sebelum Anda memulai, pastikan Rust dan Anchor sudah terinstalasi (lihat [dokumentasi resmi](https://www.anchor-lang.com/docs/installation) jika Anda perlu referensi ulang). Kemudian di _terminal_ Anda, jalankan:

```bash
anchor init blueshift_anchor_vault
```

Kita tidak memerlukan _crate_ tambahan untuk tantangan ini, jadi Anda sekarang dapat membuka folder yang baru dibuat, dan Anda siap untuk mulai koding!

<ArticleSection name="Kerangka Awal" id="template" level="h2" />

Mari kita mulai dengan struktur program dasar. Kita akan mengimplementasikan semua fitur dalam file `lib.rs` berhubung program yang kita buat adalah program yang sederhana. Berikut ini adalah kerangka awal dengan komponen inti yang akan kita butuhkan:

```rust
declare_id!("22222222222222222222222222222222222222222222");

#[program]
pub mod blueshift_anchor_vault {
    use super::*;

    pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
        // deposit logic
        Ok(())
    }

    pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
        // withdraw logic
        Ok(())
    }
}

#[derive(Accounts)]
pub struct VaultAction<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        mut,
        _seed_ = [b"_vault_", signer.key().as_ref()],
        bump,
    )]
    pub _vault_: SystemAccount<'info>,
    pub system_program: Program<'info, System>,
}

#[error_code]
pub enum VaultError {
    // error enum
}
```

**Catatan**: Jangan lupa untuk mengubah ID program menjadi `22222222222222222222222222222222222222222222` karena kami menggunakan ID ini di balik layar untuk memeriksa program Anda.

<ArticleSection name="Rangkaian Akun" id="accounts" level="h2" />

Kita dapat membuat satu konteks bernama `VaultAction` dan menggunakannya untuk funsgi `deposit` dan fungsi `withdraw`. Alasan desain akun seperti ini adalah kesederhanaan implementasi dan pembacaan.

Struktur akun `VaultAction` akan memerlukan:

- `signer`: ini adalah pemilik _vault_, dan satu-satunya orang yang dapat menarik _lamport_ setelah membuat _vault_.
- `_vault_`: PDA yang diturunkan dari _seeds_ berikut: `[b"_vault_", signer.key().as_ref()]` yang menyimpan _lamport_ untuk `signer`.
- `system_program`: akun program sistem bawaan Solana yang perlu disertakan karena kita akan menggunakan instruksi transfer CPI yang terdapat dalam program ini.

`struct` akun akan terlihat seperti berikut:

```rust
#[derive(Accounts)]
pub struct VaultAction<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        mut,
        _seed_ = [b"_vault_", signer.key().as_ref()],
        bump,
    )]
    pub _vault_: SystemAccount<'info>,
    pub system_program: Program<'info, System>,
}
```

Mari kita bahas setiap _constraint_ (batasan) pada akun-akun ini:

1. `signer`: Batasan `mut` diperlukan karena kita akan mengubah nilai saldo lamports selama transfer.
2. `_vault_`:

   - `mut` karena nilai saldo lamports akan berubah.
   - `_seed_` & `bumps` mendefinisikan cara menurunkan PDA yang sah dari _seeds_.

3. `system_program`: memastikan dua hal, yaitu apakah akun diatur sebagai akun yang dapat dieksekusi (_executable_) dan _address_ benar adalah _address_ dari System Program.

<ArticleSection name="Definisi Error" id="errors" level="h2" />

Kita tidak memerlukan banyak definisi error untuk program kecil ini, jadi kita hanya akan membuat 2 enum:

- `VaultAlreadyExists` (_vault_ Sudah Tersedia): yang memberi tahu kita jika sudah ada beberapa lamports di akun, yang menandakan bahwa _vault_ sudah tersedia.
- `InvalidAmount` (Jumlah Tidak Sah): kita tidak dapat menyetor jumlah yang kurang dari _rent_ minimum untuk akun dasar, jadi kita memeriksa bahwa jumlahnya lebih besar dari itu.

Definisi Error akan terlihat seperti berikut:

```rust
#[error_code]
pub enum VaultError {
    #[msg("_vault_ already exists")]
    VaultAlreadyExists,
    #[msg("Invalid amount")]
    InvalidAmount,
}
```

<ArticleSection name="Deposit" id="deposit" level="h2" />

Kita akan membuat fungsi `deposit` yang akan menjalankan langkah-langkah berikut:

1. Memastikan _vault_ kosong (tidak memiliki _lamports_) untuk mencegah deposit ganda.
2. Memastikan bahwa jumlah deposit melebihi jumlah bebas biaya _rent_ (sewa) untuk `SystemAccount`
3. Transfer _lamport_ dari penandatangan ke _vault_ menggunakan eksekusi CPI ke Program Sistem.

Mari kita implementasikan rangkaian verifikasi ini terlebih dahulu:

```rust
// Verifikasi vault kosong
require_eq!(ctx.accounts._vault_.lamports(), 0, VaultError::VaultAlreadyExists);

// Verifikasi jumlah melebihi jumlah bebas biaya rent
require_gt!(amount, Rent::get()?.minimum_balance(0), VaultError::InvalidAmount);
```

Dua makro `require` diatas bertindak seperti klausa penjaga yang di kustomisasi:

- `require_eq!` mengonfirmasi bahwa _vault_ kosong (mencegah deposit ganda).
- `require_gt!` memeriksa jumlah melewati ambang batas bebas biaya _rent_.

Setelah verifikasi berhasil, fungsi bantuan Program Sistem Anchor memanggil Fungsi CPI `Transfer` seperti berikut:

```rust
use anchor_lang::system_program::{transfer, Transfer};

transfer(
    CpiContext::new(
        ctx.accounts.system_program.to_account_info(),
        Transfer {
            from: ctx.accounts.signer.to_account_info(),
            to: ctx.accounts._vault_.to_account_info(),
        },
    ),
    amount,
)?;
```

<ArticleSection name="Penarikan" id="withdraw" level="h2" />

Instruksi `withdraw` di rencanakan untuk dapat menjalankan langkah-langkah berikut:

1. Verifikasi _vault_ berisi _lamport_ (tidak kosong)
2. Menggunakan PDA _vault_ untuk menandatangani transfer atas namanya sendiri
3. Transfer semua _lamport_ dari _vault_ kembali ke penandatangan

Pertama, mari kita periksa apakah _vault_ memiliki _lamport_ untuk ditarik:

```rust
// Verifikasi _vault_ memiliki _lamport_ untuk ditarik
require_neq!(ctx.accounts._vault_.lamports(), 0, VaultError::InvalidAmount);
```

Kemudian, kita perlu membuat _seed_ penandatangan PDA dan melakukan transfer:

```rust
// Membuat seed penandatangan PDA
let signer_key = ctx.accounts.signer.key();
let signer_seeds = &[b"_vault_", signer_key.as_ref(), &[ctx.bumps._vault_]];

// Transfer semua lamport dari vault ke penandatangan
transfer(
    CpiContext::new_with_signer(
        ctx.accounts.system_program.to_account_info(),
        Transfer {
            from: ctx.accounts._vault_.to_account_info(),
            to: ctx.accounts.signer.to_account_info(),
        },
        &[&signer_seeds[..]]
    ),
    ctx.accounts._vault_.lamports()
)?;
```

Keamanan penarikan ini dijamin oleh dua faktor:

1. PDA dari _vault_ merupakan nilai yang diturunkan dari kunci publik penandatangan, dimana hal ini memastikan hanya penyetor asli yang dapat melakukan penarikan.
2. Eligibilitas PDA untuk menandatangani transfer telah diverifikasi melalui _seeds_ yang kita masukkan ke konteks `CpiContext::new_with_signer`.

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

Sekarang Anda dapat menguji program Anda terhadap unit test kami dan mendapatkan NFT Anda!

Mulailah dengan membangun program Anda menggunakan perintah berikut di _terminal_ Anda

```bash
anchor build
```

Perintah ini akan menghasilkan file `.so` langsung di folder `target/deploy` Anda.

Sekarang klik tombol `Ambil Tantangan` dan upload file tersebut di sana!
