# Pinjam

Instruksi peminjaman adalah bagian pertama dari sistem _flash loan_ kita. Instruksi ini melakukan tiga langkah penting untuk memastikan peminjaman yang aman dan atomik:

1. Transfer dana: Memindahkan nilai `borrow_amount` (jumlah pinjaman) yang diminta dari pembendaharaan protokol ke akun peminjam
2. Verifikasi pembayaran kembali: Menggunakan introspeksi instruksi untuk memastikan bahwa instruksi pembayaran kembali yang sah benar-benar terdapat di akhir transaksi

<ArticleSection name="Transfer Dana" id="fund-transfer" level="h2" />

Pertama, kita mengimplementasikan fitur transfer dana dengan validasi yang tepat:

```rust
// Make sure we're not sending in an invalid amount that can crash our Protocol
require!(borrow_amount > 0, ProtocolError::InvalidAmount);

// Derive the Signer Seeds for the Protocol Account
let seeds = &[
    b"protocol".as_ref(),
    &[ctx.bumps.protocol]
];
let signer_seeds = &[&seeds[..]];

// Transfer the funds from the protocol to the borrower
transfer(
    CpiContext::new_with_signer(
        ctx.accounts.token_program.to_account_info(),
        Transfer {
            from: ctx.accounts.protocol_ata.to_account_info(),
            to: ctx.accounts.borrower_ata.to_account_info(),
            authority: ctx.accounts.protocol.to_account_info(),
        },
        signer_seeds
    ),
    borrow_amount
)?;
```

Kode ini memastikan kita mentransfer jumlah yang sah dan menggunakan Program Derived Address (PDA) protokol untuk otorisasi transfer.

<ArticleSection
  name="Introspeksi Instruksi"
  id="instruction-introspection"
  level="h2"
/>

Sekarang bagian yang sangat vital untuk keamanan: menggunakan introspeksi instruksi untuk memverifikasi struktur transaksi dan memastikan _flash loan_ kita akan dibayar kembali.

Kita mulai dengan mengakses sysvar `instructions`, yang berisi informasi tentang semua instruksi dalam transaksi saat ini:

```rust
/*
    Instruction Introspection

    Ini adalah cara utama bagaimana kita memastikan program kita aman,
    memastikan atomisitas sambil memberikan pengalaman pengguna yang sangat baik.
*/

let ixs = ctx.accounts.instructions.to_account_info();
```

Akhirnya, kita melakukan pemeriksaan yang paling penting: memastikan bahwa instruksi terakhir dalam transaksi adalah instruksi pembayaran kembali yang sah:

- Kita mulai dengan memeriksa posisi instruksi peminjaman untuk memastikan itu benar adalah instruksi peminjaman yang satu-satunya
- Kemudian kita memeriksa jumlah instruksi dan memastikan bahwa kita benar telah memuat instruksi terakhir dari transaksi
- Lalu kita memverifikasi bahwa itu benar adalah instruksi pelunasan dengan memverifikasi ID program dan diskriminator instruksi
- Kita selesai dengan memverifikasi bahwa _Associated Token Account_ (ATA) yang diteruskan dalam instruksi pembayaran kembali sama dengan yang kita teruskan dalam instruksi `Borrow` kita

```rust
/*
    Pemeriksaan Instruksi Pembayaran Kembali

    Pastikan bahwa instruksi terakhir dalam transaksi adalah instruksi pembayaran kembali (repay)
*/

// Periksa apakah ini adalah instruksi pertama dalam transaksi.
let current_index = load_current_index_checked(&ctx.accounts.sysvar_instructions)?;
require_eq!(current_index, 0, ProtocolError::InvalidIx);

// Periksa berapa banyak instruksi yang ada dalam transaksi ini
let instruction_sysvar = ixs.try_borrow_data()?;
let len = u16::from_le_bytes(instruction_sysvar[0..2].try_into().unwrap());

// Pastikan kita memiliki instruksi pembayaran kembali
if let Ok(repay_ix) = load_instruction_at_checked(len as usize - 1, &ixs) {

    // Pemeriksaan instruksi
    require_keys_eq!(repay_ix.program_id, ID, ProtocolError::InvalidProgram);
    require!(repay_ix.data[0..8].eq(instruction::Repay::DISCRIMINATOR), ProtocolError::InvalidIx);

    // Kita dapat memeriksa Wallet dan Mint secara terpisah tetapi dengan memeriksa ATA kita melakukan ini secara otomatis
    require_keys_eq!(repay_ix.accounts.get(3).ok_or(ProtocolError::InvalidBorrowerAta)?.pubkey, ctx.accounts.borrower_ata.key(), ProtocolError::InvalidBorrowerAta);
    require_keys_eq!(repay_ix.accounts.get(4).ok_or(ProtocolError::InvalidProtocolAta)?.pubkey, ctx.accounts.protocol_ata.key(), ProtocolError::InvalidProtocolAta);

} else {
    return Err(ProtocolError::MissingRepayIx.into());
}
```
