import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Instructions

Now that you understand sBPF's registers and memory regions, let's examine the instructions that manipulate them. 

Instructions are the fundamental operations your program performs—adding numbers, loading from memory, or jumping to different locations.

<ArticleSection name="What are Instructions?" id="what-are-instructions" level="h2" />

Instructions are your program's basic building blocks. Think of them as commands that tell the processor exactly what to do:
- `add64 r1, r2`: "Add the values in registers `r1` and `r2`, store result in `r1`"
- `ldxdw r0, [r10 - 8]`: "Load 8 bytes from stack memory into register `r0`"
- `jeq r1, 42, +3`: "If `r1` equals 42, jump forward 3 instructions"

Each instruction performs exactly one operation and encodes as precisely 8 bytes of data for instant VM decoding.

sBPF instructions work with different data sizes:
- byte = 8 bits (1 byte)
- halfword = 16 bits (2 bytes) 
- word = 32 bits (4 bytes)
- doubleword = 64 bits (8 bytes)

Most sBPF operations use 64-bit values (doublewords) since registers are 64 bits, but you can load and store smaller sizes when needed for efficiency tho.

<ArticleSection name="Instruction Categories and Format" id="instruction-categories-and-format" level="h2" />

When you compile Rust, C, or assembly code, the toolchain emits a stream of fixed-width, 8-byte instructions packed into your ELF's `.text` section.

Each instruction follows a consistent structure that the VM can decode in a single pass:

```
   1 byte    4 bits   4 bits     2 bytes         4 bytes
┌──────────┬────────┬────────┬──────────────┬──────────────────┐
│  opcode  │  dst   │  src   │   offset     │      imm         │
└──────────┴────────┴────────┴──────────────┴──────────────────┘
```

- `opcode`: Defines the operation type. The top 3 bits select the instruction class (arithmetic, memory, jump, call, exit), while the lower 5 bits specify the exact variant (add, multiply, load, jump-if-equal).
- `dst`: The destination register number (`r0–r10`) where results are stored—arithmetic results, loaded values, or helper function returns.
- `src`: The source register providing input. For two-operand arithmetic (`add r1, r2`), it supplies the second value. For memory operations, it can provide the base address. For immediate variants (`add r1, 10`), these 4 bits fold into the opcode.
- `offset`: A small integer that modifies instruction behavior. For loads/stores, it's added to the source address to reach `[src + offset]`. For jumps, it's a relative branch target measured in instructions.
- `imm`:The immediate value field. Arithmetic operations use it for constants (`add r1, 42`), `CALL` uses it for syscall numbers (`sol_log = 16`), and memory operations may treat it as an absolute pointer.

### Instruction Categories

Different instruction types use these fields in specific ways:

- **Data Movement**: Move values between registers and memory:

```assembly
mov64 r1, 42           # Put immediate value 42 into r1
                       # opcode=move_imm, dst=1, src=unused, imm=42

ldxdw r0, [r10 - 8]    # Load 8 bytes from stack into r0  
                       # opcode=load64, dst=0, src=10, offset=-8, imm=unused

stxdw [r1 + 16], r0    # Store r0 to memory at [r1 + 16]
                       # opcode=store64, dst=1, src=0, offset=16, imm=unused
```
- **Arithmetic**: Perform mathematical operations:

```assembly
add64 r1, r2           # r1 = r1 + r2
                       # opcode=add_reg, dst=1, src=2, offset=unused, imm=unused

add64 r1, 100          # r1 = r1 + 100  
                       # opcode=add_imm, dst=1, src=unused, offset=unused, imm=100
```

- **Control Flow**: Change execution sequence:

```assembly
ja +5                  # Jump forward 5 instructions unconditionally
                       # opcode=jump, dst=unused, src=unused, offset=5, imm=unused

jeq r1, r2, +3         # If r1 == r2, jump forward 3 instructions
                       # opcode=jump_eq_reg, dst=1, src=2, offset=3, imm=unused

jeq r1, 42, +3         # If r1 == 42, jump forward 3 instructions  
                       # opcode=jump_eq_imm, dst=1, src=unused, offset=3, imm=42
```

### Opcode Encoding

The opcode encoding captures multiple pieces of information beyond just the operation type:
- Instruction class: Arithmetic, memory, jump, call, etc.
- Operation size: 32-bit vs 64-bit operations
- Source type: Register vs immediate value
- Specific operation: Add vs subtract, load vs store, etc.

This creates distinct opcodes for instruction variants. For example, `add64 r1, r2` (register source) uses a different opcode than `add64 r1, 42 `(immediate source). Similarly, `add64` and `add32` have different opcodes for different operation sizes.

Arithmetic operations further distinguish between signed and unsigned variants. `udiv64` treats values as unsigned (0 to 18 quintillion), while `sdiv64` handles signed values (-9 quintillion to +9 quintillion).

<ArticleSection name="Instruction Execution" id="instruction-execution" level="h2" />

The opcode determines how the VM interprets the remaining fields. 

When the VM encounters `add64 r1, r2`, it reads the opcode and recognizes this as a 64-bit arithmetic operation using two registers: 

The `dst` field indicates the result goes into `r1`, the `src` field specifies `r2` as the second operand, and the `offset` and `immediate` fields are ignored.

For `add64 r1, 42`, the opcode changes to indicate an immediate operation. Now `dst` still points to `r1`, but `src` becomes meaningless, and the `immediate` field provides the second operand (42).

Memory operations combine multiple fields meaningfully: 

For `ldxdw r1, [r2+8]`, the opcode indicates a 64-bit memory load, `dst` receives the loaded value, `src` provides the base address, and `offset` (8) is added to create the final address `r2 + 8`.

Control flow instructions follow the same pattern: 

When you write `jeq r1, r2, +5`, the opcode encodes a conditional jump comparing two registers. If `r1` equals `r2`, the VM adds the `offset` (5) to the program counter, jumping forward 5 instructions.

> The opcode determines which fields are meaningful. The instruction format remains constant: the opcode tells you how to interpret each field, eliminating complex addressing modes or special cases.

### Function Calls and Syscalls

sBPF's call mechanism evolved across versions for better clarity and security. Until sBPF v3, `call imm` served dual purposes: the immediate value determined whether you were calling an internal function or invoking a syscall. 

The runtime distinguished between these based on the immediate value range, with syscall numbers typically being small positive integers like 16 for `sol_log`.

From sBPF v3 onwards, the instructions separated for explicit behavior. `call` off now handles internal function calls using relative offsets, while `syscall imm` explicitly invokes runtime functions. This separation makes bytecode intentions clear and enables better verification.

Indirect calls through `callx` also evolved. Earlier versions encoded the target register in the immediate field, but from v2 onwards, it's encoded in the source register field for consistency with the general instruction format.

<ArticleSection name="Opcodes Reference Table" id="opcodes-reference-table" level="h2" />

### Memory Load Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0x18` | `00011000` | until v2 | `lddw dst, imm` | Load 64-bit immediate (first slot) |
| `0x00` | `00000000` | until v2 | `lddw dst, imm` | Load 64-bit immediate (second slot) |
| `0x61` | `01100001` | until v2 | `ldxw dst, [src + off]` | Load word from memory |
| `0x69` | `01101001` | until v2 | `ldxh dst, [src + off]` | Load halfword from memory |
| `0x71` | `01110001` | until v2 | `ldxb dst, [src + off]` | Load byte from memory |
| `0x79` | `01111001` | until v2 | `ldxdw dst, [src + off]` | Load doubleword from memory |
| `0x2C` | `00101100` | from v2 | `ldxb dst, [src + off]` | Load byte from memory |
| `0x3C` | `00111100` | from v2 | `ldxh dst, [src + off]` | Load halfword from memory |
| `0x8C` | `10001100` | from v2 | `ldxw dst, [src + off]` | Load word from memory |
| `0x9C` | `10011100` | from v2 | `ldxdw dst, [src + off]` | Load doubleword from memory |

### Memory Store Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0x62` | `01100010` | until v2 | `stw [dst + off], imm` | Store word immediate |
| `0x6A` | `01101010` | until v2 | `sth [dst + off], imm` | Store halfword immediate |
| `0x72` | `01110010` | until v2 | `stb [dst + off], imm` | Store byte immediate |
| `0x7A` | `01111010` | until v2 | `stdw [dst + off], imm` | Store doubleword immediate |
| `0x63` | `01100011` | until v2 | `stxw [dst + off], src` | Store word from register |
| `0x6B` | `01101011` | until v2 | `stxh [dst + off], src` | Store halfword from register |
| `0x73` | `01110011` | until v2 | `stxb [dst + off], src` | Store byte from register |
| `0x7B` | `01111011` | until v2 | `stxdw [dst + off], src` | Store doubleword from register |
| `0x27` | `00100111` | from v2 | `stb [dst + off], imm` | Store byte immediate |
| `0x37` | `00110111` | from v2 | `sth [dst + off], imm` | Store halfword immediate |
| `0x87` | `10000111` | from v2 | `stw [dst + off], imm` | Store word immediate |
| `0x97` | `10010111` | from v2 | `stdw [dst + off], imm` | Store doubleword immediate |
| `0x2F` | `00101111` | from v2 | `stxb [dst + off], src` | Store byte from register |
| `0x3F` | `00111111` | from v2 | `stxh [dst + off], src` | Store halfword from register |
| `0x8F` | `10001111` | from v2 | `stxw [dst + off], src` | Store word from register |
| `0x9F` | `10011111` | from v2 | `stxdw [dst + off], src` | Store doubleword from register |

### Control Flow Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0x05` | `00000101` | all | `ja off` | Unconditional jump |
| `0x15` | `00010101` | all | `jeq dst, imm, off` | Jump if equal to immediate |
| `0x1D` | `00011101` | all | `jeq dst, src, off` | Jump if equal to register |
| `0x25` | `00100101` | all | `jgt dst, imm, off` | Jump if greater than immediate (unsigned) |
| `0x2D` | `00101101` | all | `jgt dst, src, off` | Jump if greater than register (unsigned) |
| `0x35` | `00110101` | all | `jge dst, imm, off` | Jump if greater or equal immediate (unsigned) |
| `0x3D` | `00111101` | all | `jge dst, src, off` | Jump if greater or equal register (unsigned) |
| `0x45` | `01000101` | all | `jset dst, imm, off` | Jump if bit set (immediate mask) |
| `0x4D` | `01001101` | all | `jset dst, src, off` | Jump if bit set (register mask) |
| `0x55` | `01010101` | all | `jne dst, imm, off` | Jump if not equal to immediate |
| `0x5D` | `01011101` | all | `jne dst, src, off` | Jump if not equal to register |
| `0x65` | `01100101` | all | `jsgt dst, imm, off` | Jump if greater than immediate (signed) |
| `0x6D` | `01101101` | all | `jsgt dst, src, off` | Jump if greater than register (signed) |
| `0x75` | `01110101` | all | `jsge dst, imm, off` | Jump if greater or equal immediate (signed) |
| `0x7D` | `01111101` | all | `jsge dst, src, off` | Jump if greater or equal register (signed) |
| `0xA5` | `10100101` | all | `jlt dst, imm, off` | Jump if less than immediate (unsigned) |
| `0xAD` | `10101101` | all | `jlt dst, src, off` | Jump if less than register (unsigned) |
| `0xB5` | `10110101` | all | `jle dst, imm, off` | Jump if less or equal immediate (unsigned) |
| `0xBD` | `10111101` | all | `jle dst, src, off` | Jump if less or equal register (unsigned) |
| `0xC5` | `11000101` | all | `jslt dst, imm, off` | Jump if less than immediate (signed) |
| `0xCD` | `11001101` | all | `jslt dst, src, off` | Jump if less than register (signed) |
| `0xD5` | `11010101` | all | `jsle dst, imm, off` | Jump if less or equal immediate (signed) |
| `0xDD` | `11011101` | all | `jsle dst, src, off` | Jump if less or equal register (signed) |

### Function Call Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0x85` | `10000101` | until v3 | `call imm` or `syscall imm` | Call function or syscall |
| `0x85` | `10000101` | from v3 | `call off` | Call function with relative offset |
| `0x8D` | `10001101` | until v2 | `callx imm` | Indirect call (register in imm field) |
| `0x8D` | `10001101` | from v2 | `callx src` | Indirect call (register in src field) |
| `0x95` | `10010101` | until v3 | `exit` or `return` | Return from function |
| `0x95` | `10010101` | from v3 | `syscall imm` | Call syscall |
| `0x9D` | `10011101` | from v3 | `exit` or `return` | Return from function |

### Product/Quotient/Remainder Operations (sBPF v2+)

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0x36` | `00110110` | from v2 | `uhmul64 dst, imm` | Unsigned high multiply 64-bit immediate |
| `0x3E` | `00111110` | from v2 | `uhmul64 dst, src` | Unsigned high multiply 64-bit register |
| `0x46` | `01000110` | from v2 | `udiv32 dst, imm` | Unsigned divide 32-bit immediate |
| `0x4E` | `01001110` | from v2 | `udiv32 dst, src` | Unsigned divide 32-bit register |
| `0x56` | `01010110` | from v2 | `udiv64 dst, imm` | Unsigned divide 64-bit immediate |
| `0x5E` | `01011110` | from v2 | `udiv64 dst, src` | Unsigned divide 64-bit register |
| `0x66` | `01100110` | from v2 | `urem32 dst, imm` | Unsigned remainder 32-bit immediate |
| `0x6E` | `01101110` | from v2 | `urem32 dst, src` | Unsigned remainder 32-bit register |
| `0x76` | `01110110` | from v2 | `urem64 dst, imm` | Unsigned remainder 64-bit immediate |
| `0x7E` | `01111110` | from v2 | `urem64 dst, src` | Unsigned remainder 64-bit register |
| `0x86` | `10000110` | from v2 | `lmul32 dst, imm` | Low multiply 32-bit immediate |
| `0x8E` | `10001110` | from v2 | `lmul32 dst, src` | Low multiply 32-bit register |
| `0x96` | `10010110` | from v2 | `lmul64 dst, imm` | Low multiply 64-bit immediate |
| `0x9E` | `10011110` | from v2 | `lmul64 dst, src` | Low multiply 64-bit register |
| `0xB6` | `10110110` | from v2 | `shmul64 dst, imm` | Signed high multiply 64-bit immediate |
| `0xBE` | `10111110` | from v2 | `shmul64 dst, src` | Signed high multiply 64-bit register |
| `0xC6` | `11000110` | from v2 | `sdiv32 dst, imm` | Signed divide 32-bit immediate |
| `0xCE` | `11001110` | from v2 | `sdiv32 dst, src` | Signed divide 32-bit register |
| `0xD6` | `11010110` | from v2 | `sdiv64 dst, imm` | Signed divide 64-bit immediate |
| `0xDE` | `11011110` | from v2 | `sdiv64 dst, src` | Signed divide 64-bit register |
| `0xE6` | `11100110` | from v2 | `srem32 dst, imm` | Signed remainder 32-bit immediate |
| `0xEE` | `11101110` | from v2 | `srem32 dst, src` | Signed remainder 32-bit register |
| `0xF6` | `11110110` | from v2 | `srem64 dst, imm` | Signed remainder 64-bit immediate |
| `0xFE` | `11111110` | from v2 | `srem64 dst, src` | Signed remainder 64-bit register |

### Byte Swap Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0xDC` | `11011100` | all | `be dst, imm` | Byte swap (16, 32, or 64 bit) |
| `0xD4` | `11010100` | until v2 | `le dst, imm` | Little endian convert (deprecated) |

### Special Operations

| Opcode | Binary | Feature Set | Mnemonic | Description |
|--------|--------|-------------|----------|-------------|
| `0xF7` | `11110111` | from v2 | `hor64 dst, imm` | High-order 32-bit OR |